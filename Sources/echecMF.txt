#include <iostream>
#include <csignal>

#include <atomic>
#include "Tool/Timer.hpp"

/*

set INCLUDES_PATH_DEP=^
	D:\Dev\Opencv4\build_vc15_x64\install\include ^
	D:\Dev\LibJpeg\libjpeg-turbo-1.5.2 ^
	D:\Dev\h264\openh264\codec\api\ ^
	D:\Dev\h264\openh264\test\utils

set LIBRARIES_PATH_DEP=^
	D:\Dev\Opencv4\build_vc15_x64\install\x64\vc15\lib ^
	D:\Dev\LibJpeg\build_vc17x64\Release ^
	D:\Dev\h264\openh264\bin\x64\Release
 
set LIBRARIES_NAME_DEP=^
	ws2_32.lib ^
	opencv_core400.lib ^
	opencv_imgproc400.lib ^
	opencv_highgui400.lib ^
	opencv_imgcodecs400.lib ^
	opencv_dnn400.lib ^
	opencv_videoio400.lib ^
	turbojpeg.lib ^
	welsenc.lib ^
	welsdec.lib ^
    dxva2.lib ^
    evr.lib ^
    mf.lib ^
    mfplat.lib ^
    mfplay.lib ^
    mfreadwrite.lib ^
    mfuuid.lib ^
	Ole32.lib ^
	Shlwapi.lib ^
	Comctl32.lib ^
	Strmiids.lib 	^
	Quartz.lib ^
	user32.lib ^
	gdi32.lib ^
	user32.lib ^
	kernel32.lib ^
	msimg32.lib

*/

// Media Foundation
#include <ctime>
#include <tchar.h>
#include <new>
#include <windowsx.h>
#include <windowsx.h>
#include <Dshow.h>
#include <dvdmedia.h>
#include <codecapi.h>
#include <d3d11.h>
#include <d3d9.h>
#include <d3d9caps.h>
#include <d3d9types.h>
#include <dxva.h>
#include <dxva2api.h>
#include <dxvahd.h>
#include <evr.h>
#include <evr9.h>
#include <mfapi.h>
#include <mfcaptureengine.h>
#include <Mferror.h>
#include <Mfobjects.h>
#include <mfidl.h>
#include <mfmediacapture.h>
#include <mfmediaengine.h>
#include <mfmp2dlna.h>
#include <mfobjects.h>
#include <mfplay.h>
#include <mfreadwrite.h>
#include <mftransform.h>
#include <opmapi.h>
#include <wmcodecdsp.h>
#include <wmcontainer.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <powrprof.h>

// ---- Class ---
class CaptureEngineCB : public IMFCaptureEngineOnEventCallback {
private:
	long m_cRef;
	std::atomic<bool> _init;
	std::atomic<bool> _start;
	
public:
	CaptureEngineCB() : m_cRef(1), _init(false), _start(false) { }
	
	bool started() {
		return _start;
	}

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv) {
		static const QITAB qit[] = {
			QITABENT(CaptureEngineCB, IMFCaptureEngineOnEventCallback),
			{ 0 }
		};
		
		return QISearch(this, qit, riid, ppv);
	} 
	
	STDMETHODIMP_(ULONG) AddRef() {
		return InterlockedIncrement(&m_cRef);
	}
	
	STDMETHODIMP_(ULONG) Release() {
		LONG cRef = InterlockedDecrement(&m_cRef);
		if (cRef == 0)
			delete this;
		
		return cRef;
	}

	STDMETHODIMP OnEvent(IMFMediaEvent* pEvent) {
		std::cout << "------ Event ------ " << std::endl;
		
		HRESULT 				hrStatus;
		GUID 					guidType;
		MediaEventType 	type;
		PROPVARIANT 		value;
		
		if(pEvent->GetStatus(&hrStatus) != S_OK)
			return E_FAIL;
		
		if(pEvent->GetType(&type) != S_OK)
			return E_FAIL;
		
		if(pEvent->GetExtendedType(&guidType) != S_OK)
			return E_FAIL;
		
		if(pEvent->GetValue(&value) != S_OK)
			return E_FAIL;
		
		
		std::cout << " Status: " 	<< (hrStatus == S_OK ? "Success" : "Failure") << std::endl;
		
		std::cout << " Type: ";	
		if			(type ==  __MIDL___MIDL_itf_mfobjects_0000_0012_0001::MEExtendedType) std::cout << "MEExtendedType";
		else 		std::cout << "Other";
		std::cout << std::endl;
		
		std::cout << " Guid: ";
		if			(guidType ==  MF_CAPTURE_ENGINE_INITIALIZED) 		std::cout << "MF_CAPTURE_ENGINE_INITIALIZED";
		else if	(guidType ==  MF_CAPTURE_ENGINE_PREVIEW_STOPPED) 	std::cout << "MF_CAPTURE_ENGINE_PREVIEW_STOPPED";
		else if	(guidType ==  MF_CAPTURE_ENGINE_PREVIEW_STARTED) 	std::cout << "MF_CAPTURE_ENGINE_PREVIEW_STARTED";
		else if	(guidType ==  MF_CAPTURE_ENGINE_ERROR) 				std::cout << "MF_CAPTURE_ENGINE_ERROR";
		else 		std::cout << "Other";
		
		pEvent->Release();
		std::cout << std::endl  << std::endl;
		
		// Initialization
		if(hrStatus == S_OK) {
			if(guidType ==  MF_CAPTURE_ENGINE_INITIALIZED)
				_init = true;
			else if(guidType == MF_CAPTURE_ENGINE_PREVIEW_STARTED)
				_start = true;
			else if(guidType == MF_CAPTURE_ENGINE_PREVIEW_STOPPED)
				_start = false;
		}
		
		return S_OK;
	}
	
	STDMETHODIMP waitForInit(int ms = -1) {
		Timer timer;
		while(!_init) {
			timer.wait(2);
			if(ms < 0)
				continue;
			
			if(timer.elapsed_mus() / 1000 > ms)
				return E_FAIL;
		}
		
		return S_OK;
	}
	
	STDMETHODIMP waitForStart(int ms = -1) {
		Timer timer;
		while(!_start) {
			timer.wait(2);
			if(ms < 0)
				continue;
			
			if(timer.elapsed_mus() / 1000 > ms)
				return E_FAIL;
		}
		
		return S_OK;
	}
	
	STDMETHODIMP waitForStop(int ms = -1) {
		Timer timer;
		while(_start) {
			timer.wait(2);
			if(ms < 0)
				continue;
			
			if(timer.elapsed_mus() / 1000 > ms)
				return E_FAIL;
		}
		
		return S_OK;
	}
};

class CaptureSampleCB : public IMFCaptureEngineOnSampleCallback {
private:
	long m_cRef;
	CRITICAL_SECTION m_critsec;
	
public:
	CaptureSampleCB() : m_cRef(1) { 
		InitializeCriticalSection(&m_critsec);
	}
	~CaptureSampleCB() {
		DeleteCriticalSection(&m_critsec);
	}

	STDMETHODIMP QueryInterface(REFIID riid, void** ppv) {
		static const QITAB qit[] = {
			QITABENT(CaptureSampleCB, IMFCaptureEngineOnSampleCallback),
			{ 0 }
		};
		
		return QISearch(this, qit, riid, ppv);
	} 
	
	STDMETHODIMP_(ULONG) AddRef() {
		return InterlockedIncrement(&m_cRef);
	}
	
	STDMETHODIMP_(ULONG) Release() {
		LONG cRef = InterlockedDecrement(&m_cRef);
		if (cRef == 0)
			delete this;
		
		return cRef;
	}

	STDMETHODIMP OnSample(IMFSample* pSample) {
		EnterCriticalSection(&m_critsec);
		std::cout << "------ Sample ------ " << std::endl;

		pSample->Release();
		
		LeaveCriticalSection(&m_critsec);
		return S_OK;
	}
};


namespace Globals {
	// Variables
	volatile std::sig_atomic_t signalStatus = 0;
	
	// Define engine
	IMFCaptureEngineClassFactory* 	pFactory 	= nullptr;
	IMFAttributes*						pAttrEngine = nullptr;
	IMFCaptureEngine*					pEngine		= nullptr;
	IMFCapturePreviewSink*				pPreview 	= nullptr;
	IMFCaptureSource* 					pCapSource 	= nullptr;
    IMFCaptureSink*						pSink			= nullptr;
	IMFMediaSource* 						pSource 		= nullptr;
    IMFMediaType*							pMediaType	= nullptr;
    IMFMediaType*							pMediaType2	= nullptr;
	
	CaptureEngineCB*						pCallback 			= nullptr;
	CaptureSampleCB*						pSampleCallback 	= nullptr;
}
using namespace Globals;

// --- Signals ---
static void sigintHandler(int signal) {
	Globals::signalStatus = signal;
}

// --- Functions ---
int returnError(const std::string& message) {
	Timer::wait(100);
	std::cout << message << std::endl;
	std::cout << "Press a key to continue..." << std::endl;
	return std::cin.get();		
}


// ----- MF helpers -----
template <class T> void SafeRelease(T **ppT) {
    if (*ppT) {
        (*ppT)->Release();
        *ppT = nullptr;
    }
}

HRESULT CopyAttribute(IMFAttributes *pSrc, IMFAttributes *pDest, const GUID& key)
{
    PROPVARIANT var;
    PropVariantInit( &var );
    HRESULT hr = pSrc->GetItem(key, &var);
    if (SUCCEEDED(hr))
    {
        hr = pDest->SetItem(key, var);
        PropVariantClear(&var);
    }
    return hr;
}


// Creates a compatible video format with a different subtype.

HRESULT CloneVideoMediaType(IMFMediaType *pSrcMediaType, REFGUID guidSubType, IMFMediaType **ppNewMediaType)
{
    IMFMediaType *pNewMediaType = NULL;

    HRESULT hr = MFCreateMediaType(&pNewMediaType);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pNewMediaType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video);     
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pNewMediaType->SetGUID(MF_MT_SUBTYPE, guidSubType);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CopyAttribute(pSrcMediaType, pNewMediaType, MF_MT_FRAME_SIZE);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CopyAttribute(pSrcMediaType, pNewMediaType, MF_MT_FRAME_RATE);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CopyAttribute(pSrcMediaType, pNewMediaType, MF_MT_PIXEL_ASPECT_RATIO);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = CopyAttribute(pSrcMediaType, pNewMediaType, MF_MT_INTERLACE_MODE);
    if (FAILED(hr))
    {
        goto done;
    }

    *ppNewMediaType = pNewMediaType;
    (*ppNewMediaType)->AddRef();

done:
    SafeRelease(&pNewMediaType);
    return hr;
}


HRESULT ChooseVideoDeviceSource(IMFMediaSource **ppSource, size_t idCapture) {
    *ppSource = nullptr;

    IMFMediaSource *pSource 		= nullptr;
    IMFAttributes *pAttributes 	= nullptr;
    IMFActivate **ppDevices 		= nullptr;

    // Create 1 attribute store to specify the enumeration parameters.
    HRESULT hr = MFCreateAttributes(&pAttributes, 1);
    if (FAILED(hr)) {
        goto done;
    }

    // Source type: video capture devices
    hr = pAttributes->SetGUID(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE, MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID);
    if (FAILED(hr)) {
        goto done;
    }

    // Enumerate devices respecting the attributes
    UINT32 count;
    hr = MFEnumDeviceSources(pAttributes, &ppDevices, &count);
    if (FAILED(hr)) {
        goto done;
    }
	
	// Display
	std::cout << "Found video capture media: (" << count << ")" << std::endl;
	for(DWORD i = 0; i < count; i++) {
		WCHAR *szFriendlyName = nullptr;
		UINT32 cchName;

		if (ppDevices[i]->GetAllocatedString(MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, &szFriendlyName, &cchName) != S_OK)
			continue;

		std::wcout << " " << szFriendlyName << std::endl;

		CoTaskMemFree(szFriendlyName);		
	}
	
	
    if (count == 0) {
        hr = E_FAIL;
        goto done;
    }

    // Create the media source object.
	std::cout << std::endl;
    hr = ppDevices[idCapture]->ActivateObject(IID_PPV_ARGS(&pSource));
    if (FAILED(hr)) {
        goto done;
    }

    *ppSource = pSource;
    (*ppSource)->AddRef();

done:
    SafeRelease(&pAttributes);

    for (DWORD i = 0; i < count; i++) {
        SafeRelease(&ppDevices[i]);
    }
    CoTaskMemFree(ppDevices);
    SafeRelease(&pSource);
    return hr;
}

HRESULT ShowMediaInfo(IMFMediaType* pMediaType) {
	std::cout << "Media [" << pMediaType << "] - Major: ";
	
	GUID guidMajorType;
	pMediaType->GetMajorType(&guidMajorType);
	if(guidMajorType == MFMediaType_Video)
		std::cout << "Video" << std::endl;
	
	AM_MEDIA_TYPE* pInfo = nullptr;
	if(pMediaType->GetRepresentation(AM_MEDIA_TYPE_REPRESENTATION, (void**)&pInfo) == S_OK) {
		if(pInfo->subtype == MFVideoFormat_YUY2)
			std::cout << "MFVideoFormat_YUY2" << std::endl;		
		else if(pInfo->subtype == MFVideoFormat_MJPG)
			std::cout << "MFVideoFormat_MJPG" << std::endl;
		
		std::cout <<  "Fixed sample size: " 	<< (pInfo->bFixedSizeSamples > 0 ? "True" : "False") 		<< std::endl;
		std::cout <<  "Compression size: "		<< (pInfo->bTemporalCompression > 0 ? "True" : "False") 	<< std::endl;
		std::cout <<  "Sample size: " 			<< pInfo->lSampleSize << std::endl;
		if(pInfo->formattype == FORMAT_VideoInfo2) {
			VIDEOINFOHEADER2 *pVih = reinterpret_cast<VIDEOINFOHEADER2*>(pInfo->pbFormat);
			std::cout << "rcSource = " << pVih->rcSource.left << " " << pVih->rcSource.top << " " << pVih->rcSource.right << " " << pVih->rcSource.bottom << std::endl;
			std::cout << "rcTarget = " << pVih->rcTarget.left << " " << pVih->rcTarget.top << " " << pVih->rcTarget.right << " " << pVih->rcTarget.bottom << std::endl;
			std::cout << "dwBitRate = " << pVih->dwBitRate << std::endl;
			std::cout << "dwBitErrorRate = " << pVih->dwBitErrorRate << std::endl;
			std::cout << "AvgTimePerFrame = " << pVih->AvgTimePerFrame << std::endl;
			std::cout << "dwInterlaceFlags = " << pVih->dwInterlaceFlags << std::endl;
			std::cout << "dwCopyProtectFlags = " << pVih->dwCopyProtectFlags << std::endl;
			std::cout << "dwPictAspectRatioX = " << pVih->dwPictAspectRatioX << std::endl;
			std::cout << "dwPictAspectRatioY = " << pVih->dwPictAspectRatioY << std::endl;
			
			BITMAPINFOHEADER bmi = pVih->bmiHeader;
			std::cout << "biSize = " << bmi.biSize << std::endl;
			std::cout << "biWidth = " << bmi.biWidth << std::endl;
			std::cout << "biHeight = " << bmi.biHeight << std::endl;
			std::cout << "biPlanes = " << bmi.biPlanes << std::endl;
			std::cout << "biBitCount = " << bmi.biBitCount << std::endl;
			std::cout << "biCompression = " << bmi.biCompression << std::endl;
			std::cout << "biSizeImage = " << bmi.biSizeImage << std::endl;
			std::cout << "biXPelsPerMeter = " << bmi.biXPelsPerMeter << std::endl;
			std::cout << "biYPelsPerMeter = " << bmi.biYPelsPerMeter << std::endl;
			std::cout << "biClrUsed = " << bmi.biClrUsed << std::endl;
			std::cout << "biClrImportant = " << bmi.biClrImportant << std::endl;
		}
	}
	else 
		return E_FAIL;
	
	return S_OK;
}

// ------ Windows ------

namespace PreviewWnd
{
    HBRUSH hBackgroundBrush = 0;

    BOOL OnCreate(HWND /*hwnd*/, LPCREATESTRUCT /*lpCreateStruct*/)
    {
        hBackgroundBrush = CreateSolidBrush(RGB(0,0,0));
        return (hBackgroundBrush != NULL);
    }

    void OnDestroy(HWND hwnd)
    {
        DeleteObject(hBackgroundBrush);
    }

    void OnPaint(HWND hwnd)
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        if (pCallback && pCallback->started())
        {
            pPreview->UpdateVideo(NULL, NULL, NULL);
        }
        else
        {
            FillRect(hdc, &ps.rcPaint, hBackgroundBrush);
        }
        EndPaint(hwnd, &ps);
    }

    void OnSize(HWND hwnd, UINT state, int /*cx*/, int /*cy*/)
    {
        if (state == SIZE_RESTORED)
        {
            InvalidateRect(hwnd, NULL, FALSE);
        }
    }

    LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        switch (uMsg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,  OnCreate);
        HANDLE_MSG(hwnd, WM_PAINT,   OnPaint);
        HANDLE_MSG(hwnd, WM_SIZE,    OnSize);
        HANDLE_MSG(hwnd, WM_DESTROY, OnDestroy);

        case WM_ERASEBKGND:
            return 1;
        }
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
};
HWND createWindow(LPCTSTR name, int width, int height, WNDPROC procCbck) {	
	//Register a new window class ex
	WNDCLASSEX  wndEx;
	wndEx.cbSize 				= sizeof(WNDCLASSEX);
	wndEx.style 				= 0;
	wndEx.lpfnWndProc 		= procCbck;
	wndEx.cbClsExtra 			= 0;
	wndEx.cbWndExtra 			= 0;
	wndEx.hInstance 			= GetModuleHandle(nullptr);
	wndEx.hIcon 				= 0;
	wndEx.hCursor 				= 0;
	wndEx.hbrBackground 	= 0;
	wndEx.lpszMenuName 		= 0;
	wndEx.lpszClassName 	= name;
	wndEx.hIconSm 				= 0;
  
	RegisterClassEx(&wndEx);

	// Create window handle
	int widthScreen  	= GetSystemMetrics(SM_CXSCREEN);
	int heightScreen 	= GetSystemMetrics(SM_CYSCREEN);

	HWND hWnd = CreateWindowEx(
		WS_EX_TRANSPARENT,				// dwExStyle 
		name, 										// lpClassName
		name,										// lpWindowName
		WS_BORDER | WS_SYSMENU,			// dwStyle 
		(widthScreen - width) / 2, 	// x
		(heightScreen - height) / 2, 	// y
		width, 									// width
		height,									// height
		(HWND)nullptr, 						// hWndParent 
		nullptr,									// hMenu 
		GetModuleHandle(nullptr), 	// hInstance 
		nullptr									// lpParam 
	);

	return hWnd;
}


// --- Entry point ---
int main(int argc, char* argv[]) {	
	// - Install signal handler
	std::signal(SIGINT, sigintHandler);
	
	// Create window
	HWND hwndMain; 
	
	hwndMain = createWindow(_T("Screen"), 1400, 1000, PreviewWnd::WindowProc);
	ShowWindow(hwndMain, 1);
	UpdateWindow(hwndMain);
	
	//  -- Init --
	if(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE) != S_OK)
		return returnError("Init thread");
	
	if(MFStartup(MF_VERSION) != S_OK) 
		return returnError("Media Foundation can't be initialized");
	
	// Create factory
	if(CoCreateInstance(CLSID_MFCaptureEngineClassFactory, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pFactory)) != S_OK) 
		return returnError("Media Foundation factory can't be initialized");
	
	// Create engine
	if(pFactory->CreateInstance(CLSID_MFCaptureEngine, IID_PPV_ARGS(&pEngine)) != S_OK) 
		return returnError("Capture engine can't be initialized");
		
	// Choose device
	if(ChooseVideoDeviceSource(&pSource, 0) != S_OK)
		return returnError("Video device can't be opened");
	
	
	// Initialize engine
	pCallback = new (std::nothrow) CaptureEngineCB();
	
	if(MFCreateAttributes(&pAttrEngine, 1) != S_OK) 
		return returnError("Create engine attribute failed");
	
	if(pAttrEngine->SetUINT32(MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY, TRUE) != S_OK) 
		return returnError("Set engine attribute failed");
	
	if(pEngine->Initialize(pCallback, pAttrEngine, nullptr, pSource) != S_OK)
		return returnError("Capture engine can't be initialized");
	
	if(pCallback->waitForInit(3000) != S_OK) // Timeout = 3 sec
		return returnError("Capture engine initialization timeout");	
		
		
	// Configure the video format for the preview sink
	if(pEngine->GetSink(MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW, &pSink) != S_OK)
		return returnError("Sink can't be created");	
	
	if(pEngine->GetSource(&pCapSource) != S_OK)
		return returnError("Source can't be reached");
	
	if(pCapSource->GetCurrentDeviceMediaType((DWORD)MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW, &pMediaType) != S_OK)
		return returnError("MediaType can't be created");
	
	if(CloneVideoMediaType(pMediaType, MFVideoFormat_RGB32, &pMediaType2)  != S_OK || pMediaType2->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)  != S_OK)
		return returnError("MediaType2 can't be created");

	// Connect the video stream to the preview sink.
	DWORD dwSinkStreamIndex;
	if(pSink->QueryInterface(IID_PPV_ARGS(&pPreview)) != S_OK)
		return returnError("Preview can't be created");
	
	if(pPreview->SetRenderHandle(hwndMain) != S_OK)
		return returnError("Preview can't be set");
		
	if(pPreview->AddStream((DWORD)MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW,  pMediaType2, nullptr, &dwSinkStreamIndex) != S_OK)
		return returnError("Stream can't be created");
	
	// pSampleCallback = new (std::nothrow) CaptureSampleCB();
	// if(pPreview->SetSampleCallback(dwSinkStreamIndex, pSampleCallback) != S_OK)
		// return returnError("Sample callback can't be set");
	
	
	// Start engine
	if(pEngine->StartPreview() != S_OK)
		return returnError("Can't start preview");	
	
	if(pCallback->waitForStart(3000) != S_OK) // Timeout = 3 sec
		return returnError("Capture engine start failed timeout");		
	
	
	// -- Loop --
	int bRet = 0;
	MSG msg;
	while( (bRet = GetMessage(&msg, nullptr, 0, 0 )) != 0 && Globals::signalStatus != SIGINT) { 
		if (bRet == -1) { 	// Error occured
			std::cout << "Error" << std::endl;
			break;
		}
		else {
			TranslateMessage(&msg); 
			DispatchMessage(&msg); 
		} 
		Timer::wait(100);
	}
	
	// End engine
	pEngine->StopPreview();
	pCallback->waitForStop(3000);
	
	// -- Cleanup --
	pSource->Shutdown();
	SafeRelease(&pSink);
	SafeRelease(&pMediaType);
	SafeRelease(&pCapSource);
	SafeRelease(&pSource);
	SafeRelease(&pCallback);
	SafeRelease(&pSampleCallback);
	SafeRelease(&pAttrEngine);
	SafeRelease(&pEngine);
	SafeRelease(&pFactory);
	MFShutdown();
	CoUninitialize();

	Timer::wait(100);
	std::cout << "Press a key to continue..." << std::endl;
	return std::cin.get();
}